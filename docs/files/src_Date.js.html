<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/Date.js - date-prototype</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="date-prototype"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 3.5.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Date.html">Date</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/Date.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function() { &quot;use strict&quot;;
	
	/*
	 * Add leading zeros
	 */
	function zeroPad(number, digits) {
		switch (digits - String(number).length) {
			case 2: return &#x27;00&#x27; + number;
			case 1: return &#x27;0&#x27; + number;
		}
		return number;
	}
	/*
	 * Extend an object with the properties of another
	 */
	function extend(d, s) {
		for (var p in s) {
			if (Object.prototype.hasOwnProperty.call(s, p)) {
				d[p] = s[p];
			}
		}
	}

	//
	// set up integers and functions for adding to a date or subtracting two dates
	//
	var multipliers = {
		millisecond: 1,
		second: 1000,
		minute: 60 * 1000,
		hour: 60 * 60 * 1000,
		day: 24 * 60 * 60 * 1000,
		week: 7 * 24 * 60 * 60 * 1000,
		month: {
			// add a number of months
			add: function(d, number) {
				var prevDay = d.getDate();
				// add any years needed (increments of 12)
				multipliers.year.add(d, Math[number &gt; 0 ? &#x27;floor&#x27; : &#x27;ceil&#x27;](number / 12));
				// ensure that we properly wrap betwen December and January
				var prevMonth = d.getMonth() + (number % 12);
				if (prevMonth == 12) {
					prevMonth = 0;
					d.setYear(d.getFullYear() + 1);
				} else if (prevMonth == -1) {
					prevMonth = 11;
					d.setYear(d.getFullYear() - 1);
				}
				d.setMonth(prevMonth);
				if (d.getDate() != prevDay) {
					// new month has fewer days in the month than previous/next month
					// so JavaScript will wrap over to next month
					d.add(-1, &#x27;month&#x27;);
					d.setDate(d.daysInMonth());
				}
			},
			// get the number of months between two Date objects (decimal to the nearest day)
			diff: function(d1, d2) {
				// get the number of years
				var diffYears = d1.getFullYear() - d2.getFullYear();
				// get the number of remaining months
				var diffMonths = d1.getMonth() - d2.getMonth() + (diffYears * 12);
				// get the number of remaining days
				var diffDays = d1.getDate() - d2.getDate();
				// return the month difference with the days difference as a decimal
				return diffMonths + (diffDays / 30);
			}
		},
		year: {
			// add a number of years
			add: function(d, number) {
				d.setYear(d.getFullYear() + Math[number &gt; 0 ? &#x27;floor&#x27; : &#x27;ceil&#x27;](number));
			},
			// get the number of years between two Date objects (decimal to the nearest day)
			diff: function(d1, d2) {
				return multipliers.month.diff(d1, d2) / 12;
			}
		}
	};
	//
	// alias each multiplier with an &#x27;s&#x27; to allow &#x27;year&#x27; and &#x27;years&#x27; for example
	//
	var m = multipliers;
	m.milliseconds = m.millisecond;
	m.seconds = m.second;
	m.minutes = m.minute;
	m.hours = m.hour;
	m.weeks = m.week;
	m.days = m.day;
	m.months = m.month;
	m.years = m.year;
	//
	// Add methods to Date instances
	//
	var instanceMethods = {
		/**
		 * Return a date one day ahead (or any other unit)
		 * @method succ
		 * @param {String} [unit=day]  The unit name (e.g. years, seconds)
		 * @return {Date}  A new Date object
		 */
		succ: function(unit) {
			return this.clone().add(1, unit || &#x27;day&#x27;);
		},
		/**
		 * Add an arbitrary time frame
		 * @method add
		 * @param {Number} number  The amount to add
		 * @param {String} [unit=day]  The unit name (e.g. years, seconds)
		 * @return {Date}
		 */
		add: function(number, unit) {
			var factor = multipliers[unit] || multipliers.day;
			if (typeof factor == &#x27;number&#x27;) {
				this.setTime(this.getTime() + (factor * number));
			} else {
				factor.add(this, number);
			}
			return this;
		},
		/**
		 * Find the difference between this date and another date. Positive means more recent
		 * @method diff
		 * @param {String|Date|Number} dateObj
		 * @param {String} [unit=day]  The unit name (e.g. years, seconds)
		 * @param {Boolean} [allowDecimal=false]  If true, return a decimal, otherwise round toward zero
		 * @return {Number|NaN}  If the other date is not recognized, return NaN
		 */
		diff: function(dateObj, unit, allowDecimal) {
			var unitDiff;
			// ensure we have a Date object
			dateObj = Date.create(dateObj);
			if (dateObj === null) {
				return NaN;
			}
			// get the multiplying factor integer or factor function
			var factor = multipliers[unit] || multipliers.day;
			if (typeof factor == &#x27;number&#x27;) {
				// multiply
				unitDiff = (this.getTime() - dateObj.getTime()) / factor;
			} else {
				// run function
				unitDiff = factor.diff(this, dateObj);
			}
			// if decimals are not allowed, round toward zero
			return (allowDecimal ? unitDiff : Math[unitDiff &gt; 0 ? &#x27;floor&#x27; : &#x27;ceil&#x27;](unitDiff));
		},
		/**
		 * Our gsub function that applies the format string using the given formatting scheme
		 * @method _applyFormat
		 * @private
		 * @param {String} formatStr  The format string such as &quot;%Y-%m-%d&quot;
		 * @param {Object} formatting  The formatting scheme set in Date.addFormat()
		 * @return {String}  Return the string representation of the date
		 */
		_applyFormat: function(formatStr, formatting) {
			// default the format string to year-month-day
			var source = formatStr || formatting.defaultFormat, result = &#x27;&#x27;, match;
			// replace each format code
			while (source.length &gt; 0) {
				if ((match = source.match(formatting.matcher))) {
					result += source.slice(0, match.index);
					result += (match[1] || &#x27;&#x27;) + this._applyFormatChar(match[2], formatting);
					source = source.slice(match.index + match[0].length);
				} 
				else {
					result += source;
					source = &#x27;&#x27;;
				}
			}
			return result;
		},
		/**
		 * Apply the format of a single character code using the given formatting scheme
		 * @method _applyFormatChar
		 * @private
		 * @param {String} code  The code such as &quot;Y&quot;
		 * @param {Object} formatting  The formatting scheme set in Date.addFormat()
		 * @return {String}  Return the string representation of the date or the code literal if not recognized
		 */
		_applyFormatChar: function(code, formatting) {
			if (formatting.shortcuts &amp;&amp; formatting.shortcuts[code]) {
				// process any shortcuts recursively
				return this._applyFormat(formatting.shortcuts[code], formatting);
			}
			else if(formatting.codes &amp;&amp; formatting.codes[code]) {
				// get the format code function and toPaddedString() argument
				var getter = formatting.codes[code].split(&#x27;.&#x27;);
				var nbr = this[&#x27;get&#x27; + getter[0]] ? this[&#x27;get&#x27; + getter[0]]() : &#x27;&#x27;;
				// zeroPad if specified
				if (getter[1]) {
					nbr = zeroPad(nbr, getter[1]);
				}
				// prepend the leading character
				return nbr;
			}
			return code;
		},
		/**
		 * Format the string using strftime or formatPhp depending on if % is present
		 * @method format
		 * @param {String} [formatStr=Date.formatting.strftime.defaultFormat]  The format
		 * @return {String}
		 */
		format: function(formatStr) {
			formatStr = formatStr || Date.formatting.strftime.defaultFormat;
			if (formatStr.indexOf(&#x27;%&#x27;) &gt; -1) {
				return this.strftime(formatStr);
			}
			return this.formatPhp(formatStr);
		},
		/**
		 * Return a two-digit year
		 * @method getShortYear
		 * @return {Number}
		 */
		getShortYear: function() {
			return this.getYear() % 100;
		},
		/**
		 * Get the number of the month, 1-12
		 * @method getMonthNumber
		 * @return {Number}
		 */
		getMonthNumber: function() {
			return this.getMonth() + 1;
		},
		/**
		 * Get the name of the month
		 * @method getMonthName
		 * @return {String}
		 */
		getMonthName: function() {
			return Date.MONTHNAMES[this.getMonth()];
		},
		/**
		 * Get the abbreviated name of the month
		 * @method getAbbrMonthName
		 * @return {String}
		 */
		getAbbrMonthName: function() {
			return Date.ABBR_MONTHNAMES[this.getMonth()];
		},
		/**
		 * Get the name of the week day (Sunday through Saturday)
		 * @method getDayName
		 * @return {String}
		 */
		getDayName: function() {
			return Date.DAYNAMES[this.getDay()];
		},
		/**
		 * Get the abbreviated name of the week day (Sunday through Saturday)
		 * @method getAbbrDayName
		 * @return {String}
		 */
		getAbbrDayName: function() {
			return Date.ABBR_DAYNAMES[this.getDay()];
		},
		/**
		 * Get the ordinal string associated with the day of the month (i.e. st, nd, rd, th)
		 * @method getDayOrdinal
		 * @return {String}
		 */
		getDayOrdinal: function() {
			return Date.ORDINALNAMES[this.getDate() % 10];
		},
		/**
		 * Get the hour on a 12-hour scheme
		 * @method getHours12
		 * @return {Number}
		 */
		getHours12: function() {
			var hours = this.getHours();
			return hours &gt; 12 ? hours - 12 : (hours === 0 ? 12 : hours);
		},
		/**
		 * Get the am or pm (uppercase)
		 * @method getAmPm
		 * @return {String}
		 */
		getAmPm: function() {
			return this.getHours() &gt;= 12 ? &#x27;PM&#x27; : &#x27;AM&#x27;;
		},
		/**
		 * Get the am or pm (lowercase)
		 * @method getAmPmLower
		 * @return {String}
		 */
		getAmPmLower: function() {
			return this.getHours() &gt;= 12 ? &#x27;pm&#x27; : &#x27;am&#x27;;
		},
		/**
		 * Get the date as a Unix timestamp
		 * @method getUnix
		 * @return {Number}
		 */
		getUnix: function() {
			return Math.round(this.getTime() / 1000, 0);
		},
		/**
		 * Get the system GMT offset in hours and minutes (e.g. +06:30) for that date
		 * NOTE: JavaScript Date objects do not have a concept of timezone.
		 * Dates are always in the timezone of the system and only vary by daylight savings changes.
		 * @method getUTCOffset
		 * @example

	// convert from UTC to local timezone
	Date.createUTC(utcdate).getTime();
	// convert local date to UTC
	Date.create(localdate).setUTCOffset(0).getTime();

		 * @return {String}
		 */
		getUTCOffset: function() {
			// divide the minutes offset by 60
			var hours = this.getTimezoneOffset() / 60;
			// decide if we are ahead of or behind GMT
			var prefix = hours &lt; 0 ? &#x27;+&#x27; : &#x27;-&#x27;;
			// remove the negative sign if any
			hours = Math.abs(hours);
			// add the +/- to the padded number of hours to : to the padded minutes
			return prefix + zeroPad(Math.floor(hours), 2) + &#x27;:&#x27; + zeroPad((hours % 1) * 60, 2);
		},
		/**
		 * Set the offset in minutes by converting date to UTC then adding or subtracting given number of seconds
		 * @method setUTCOffset 
		 * @param {Number} seconds  The number of seconds before or past UTC time
		 * @return {Date}
		 */
		setUTCOffset: function(seconds) {
			this.setTime(this.getTime() + (seconds * 60000));
			return this;
		},
		/**
		 * Set the time zone offset in minutes and seconds in the form &quot;+0200&quot; or &quot;+02:00&quot;
		 * @method setUTCOffsetString 
		 * @param {String} str  The GMT Offset
		 * @return {Date}
		 */		
		setUTCOffsetString: function(str) {
			var hoursMin = str.match(/([+\-]?)([01]\d|2[0-3])\:?([0-5]\d)/);
			if (hoursMin) {
				var seconds = parseFloat(hoursMin[2]) * 60;
				seconds += parseFloat(hoursMin[3]);
				if (hoursMin[1] == &#x27;-&#x27;) {
					seconds *= -1;
				}
				this.setUTCOffset(seconds);
			}
			return this;
		},
		/**
		 * Get the GMT offset in hours and minutes without the colon (e.g. +0630)
		 * @method getUTCOffsetNumber
		 * @return {String}
		 */
		getUTCOffsetNumber: function() {
			return this.getUTCOffset().replace(&#x27;:&#x27;,&#x27;&#x27;);
		},
		/**
		 * Get the browser-reported name for the timezone (e.g. MDT, Mountain Daylight Time)
		 * Varies across browsers and languages
		 * @method getTimezoneName
		 * @return {String}
		 */
		getTimezoneName: function() {
			var match = /(?:\((.+)\)$| ([A-Z]{3}) )/.exec(this.toString());
			return match ? (match[1] || match[2]) : &#x27;GMT&#x27; + this.getUTCOffset();
		},
		/**
		 * Convert this date to an 8-digit integer (%Y%m%d)
		 * Good for quickly comparing dates
		 * @method toYmdInt
		 * @return {Number}
		 */
		toYmdInt: function() {
			return (this.getFullYear() * 10000) + (this.getMonthNumber() * 100) + this.getDate();
		},
		/**
		 * Create a copy of this date object
		 * @method clone
		 * @return {Date}
		 */
		clone: function() {
			return new Date(this.getTime());
		},
		/**
		 * Get a textual representation of the difference between this date and now (or the given date)
		 * e.g. &quot;3 minutes ago&quot;
		 * @method diffText
		 * @param {String|Date|Number} compare  A string date, object or ms past epoch to compare to. Defaults to current date
		 * @return {String}
		 */
		diffText: function(compare) {
			var seconds = this.diff(compare || Date.current(), &#x27;seconds&#x27;);
			var diff = Math.abs(seconds);
			var rawText;
			if (diff &lt; 120) {
				// less than two minutes ago
				return seconds &gt;= 0 ? &#x27;in a moment&#x27; : &#x27;moments ago&#x27;;

			} else if (diff &lt; 3600) {
				// 2 to 59 minutes ago
				rawText = Math.floor(diff / 60) + &quot; minutes&quot;;

			} else if (diff &lt; 86400) {
				// less than 24 hours ago
				var hours = Math.floor(diff / 3600);
				var s = hours == 1 ? &#x27;&#x27; : &#x27;s&#x27;;
				rawText = hours + &quot; hour&quot; + s + &quot; ago&quot;;

			} else if (diff &lt; 172800) {
				// yesterday
				return seconds &gt; 0 ? &#x27;tomorrow&#x27; : &#x27;yesterday&#x27;;

			} else if (diff &lt; 604800) {
				// 2 to 6 days ago
				rawText = Math.floor(diff / 86400) + &quot; days&quot;;

			} else if (diff &lt; 1209600) {
				// within 14 days
				return seconds &gt; 0 ? &#x27;next week&#x27; : &#x27;last week&#x27;;

			} else if (diff &lt; 2419200) {
				// within 28 days
				rawText = Math.floor(diff / 604800) + &quot; weeks&quot;;

			} else if (diff &lt; 5184000) {
				// within 60 days
				return seconds &gt; 0 ? &#x27;next month&#x27; : &#x27;last month&#x27;;

			}	else if (diff &lt; 31536000) {
				// within 365 days
				rawText = Math.floor(diff / 2592000) + &quot; months&quot;;

			} else if (diff &lt; 63072000) {
				// within 730 days
				return seconds &gt; 0 ? &#x27;next year&#x27; : &#x27;last year&#x27;;

			} else {
				// years ago
				rawText = Math.floor(diff / 31536000) + &quot; years&quot;;

			}
			return (seconds &gt; 0 ? &#x27;in &#x27; + rawText : rawText + &#x27; ago&#x27;);
		},
		/**
		 * Get the number of days in the month
		 * @static
		 * @return {Number}
		 */
		daysInMonth: function() {
			return Date.daysInMonth(this.getFullYear(), this.getMonth()+1);
		},
		/**
		 * Return true if the year is a leap year
		 * @method isLeapYear
		 * @return {Boolean}
		 */
		isLeapYear: function() {
			return Date.daysInMonth(this.getFullYear(), 1) == 29 ? 1 : 0;
		},
		/**
		 * Return true if the date is before the given date
		 * @method isBefore
		 * @param {String|Date|Number} date  The date to which to compare
		 * @param {String} [units=milliseconds]  The unit to round to when comparing
		 * @return {Boolean}
		 */
		isBefore: function(date, units) {
			return Math.round(this.diff(date, units || &#x27;milliseconds&#x27;, true), 0) &lt; 0;
		},
		/**
		 * Return true if the date is after the given date
		 * @method isAfter
		 * @param {String|Date|Number} date  The date to which to compare
		 * @param {String} [units=milliseconds]  The unit to round to when comparing
		 * @return {Boolean}
		 */		
		isAfter: function(date, units) {
			return Math.round(this.diff(date, units || &#x27;milliseconds&#x27;, true), 0) &gt; 0;
		},
		/**
		 * Return true if the date is equal to the given date rounded to the given unit
		 * @method equals
		 * @param {String|Date|Number} date  The date to which to compare
		 * @param {String} [units=milliseconds]  The unit to round to when comparing
		 * @return {Boolean}
		 */				
		equals: function(date, units) {
			return Math.round(this.diff(date, units || &#x27;milliseconds&#x27;, true), 0) === 0;
		},
		/**
		 * Schedule a function to be run at this date. If the date is in the past, don&#x27;t run
		 * @method setTimeout
		 * @param {Function} callback  The function to run
		 * @return {Number}  The id of the setTimeout that can be used to clearTimeout
		 * @example
		 
	$D(&#x27;+15 minutes&#x27;).setTimeout(refresh);
		  
		 */	
		setTimeout: function(callback) {
			var inMs = this.getTime() - Date.current().getTime();
			if (inMs &lt; 0) {
				return undefined;
			}
			return setTimeout(callback, inMs);
		}
	};
	extend(Date.prototype, instanceMethods);
	/**
	 * ES5 Shim for converting to full ISO String in format 2013-12-19T00:00:00Z
	 * @method toISOString
	 * @return {String}
	 */
	if (!Date.prototype.toISOString) {
		Date.prototype.toISOString = function() {
			return this.setUTCOffset(0).strftime(&#x27;%Y-%m-%dT%H:%M:%S.%NZ&#x27;);
		};
	}
	//
	// Add static methods to Date
	//
	var staticMethods = {
		/**
		 * (Signature 1 of 5) Return a new Date object that is represented by the given date
		 * @method create [1]
		 * @static
		 * @param {String} date  A machine-readable date string
		 * @return {Date|NaN}  The date object or NaN if the date is not recognized
		 * @example
 
	Date.create(&#x27;Dec 19, 2013&#x27;);
	Date.create(&#x27;2013-12-19&#x27;);
	Date.create(&#x27;12/19/2013&#x27;);
	Date.create(&#x27;12/19/2013 8am&#x27;);
	Date.create(&#x27;2 hours ago&#x27;);

		 */
		/**
		 * (Signature 2 of 5) Return a new Date object that is represented by the given number
		 * @method create [2]
		 * @static
		 * @param {Number} millisecondsPastEpoch  The number of milliseconds past (or before) 1970-01-01 00:00:00
		 * @return {Date}
		 * @example
 
	Date.create(1387518450578);

		 */
		/**
		 * (Signature 3 of 5) Return a new Date object with the given date part values
		 * @method create [3]
		 * @static
		 * @param {Number} year  Four-digit year
		 * @param {Number} month  Month number where 0=January
		 * @param {Number} [day=1]  The day number, 1-31
		 * @param {Number} [hours=0]  The hour number, 0-23
		 * @param {Number} [minutes=0]  The minutes value, 0-59
		 * @param {Number} [seconds=0]  The seconds value, 0-59
		 * @param {Number} [milliseconds=0]  The milliseconds value, 0-999
		 * @return {Date}
		 * @example
 
	Date.create(2013, 11, 19);

		 */
		/**
		 * (Signature 4 of 5) Return a new Date object with the current date
		 * @method create [4]
		 * @static
		 * @return {Date}
		 * @example
 
	Date.create();

		 */		
		/**
		 * (Signature 5 of 5) Return the given date object
		 * @method create [5]
		 * @static
		 * @param {Date} date
		 * @return {Date}
		 * @example
 
	Date.create(new Date(2013, 11, 19));

		 */		
		create: function(date) {
			// 0 arguments or date is undefined
			if (typeof date == &#x27;undefined&#x27;) {
				return Date.current();
			}
			// If the passed value is already a date object, return it
			if (date instanceof Date) {
				return date;
			}
			var a = arguments;
			switch (a.length) {
				case 1:
					// If the passed value is an integer, interpret it as ms past epoch
					if (Object.prototype.toString.call(date) == &#x27;[object Number]&#x27;) {
						return new Date(date);
					}
					// trim the date
					date = String(date).replace(/^\s*(.*)\s*$/, &#x27;$1&#x27;);
					// normalize whitespace
					date = date.replace(/\s{2,}/g, &#x27; &#x27;);
					if (date === &#x27;&#x27;) {
						return Date.current();
					}
					var i = 0, pattern, ms, obj, match, regex, fn;
					// try each of our patterns
					while ((pattern = Date.create.patterns[i++])) {
						if (typeof pattern[0] == &#x27;string&#x27;) {
							// pattern[0] is the name of the pattern
							regex = pattern[1];
							fn = pattern[2];
						}
						else {
							// backwards compatibility with version 3.1
							regex = pattern[0];
							fn = pattern[1];
						}
						if (!(match = date.match(regex))) {
							continue;
						}
						if (typeof fn == &#x27;function&#x27;) {
							obj = fn(match, date);
							if (obj instanceof Date) {
								return obj;
							}
						} else {
							// fn is not a function but a string replace command
							ms = Date.parse(date.replace(regex, fn));
							if (!isNaN(ms)) {
								return new Date(ms);
							}
						}
					}
					return NaN;
				case 2: return new Date(a[0], a[1], 1);
				case 3: return new Date(a[0], a[1], a[2]);
				case 4: return new Date(a[0], a[1], a[2], a[3]);
				case 5: return new Date(a[0], a[1], a[2], a[3], a[4]);
				case 6: return new Date(a[0], a[1], a[2], a[3], a[4], a[5]);
				default:return new Date(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);
			}
		},
		/**
		 * Return a date assuming input string (or parameters) is a UTC date.
		 * Same 5 signatures as create
		 * @method createUTC
		 * @static
		 * @return {Date}
		 */
		createUTC: function() {
			var args = [].slice.call(arguments);
			var date = Date.create.apply(null, args);
			date.setUTCOffset(0);
			return date;
		},
		//
		// constants representing month names, day names, and ordinal names to allow i18n
		// (same names as Ruby Date constants)
		//
		/**
		 * Names for the months of the year
		 * @var MONTHNAMES
		 * @static
		 * @type {Array}
		 */			
		MONTHNAMES: &#x27;January February March April May June July August September October November December&#x27;.split(&#x27; &#x27;),
		/**
		 * Lookup of month number by month abbreviation (1=January, 12=December)
		 * @property MONTHNAMES_LOOKUP
		 * @static
		 * @type {Object}
		 */
		MONTHNAMES_LOOKUP: {jan:1, feb:2, mar:3, apr:4, may:5, jun:6, jul:7, aug:8, sep:9, oct:10, nov:11, dec:12},
		/**
		 * Abbreviated names for the months of the year
		 * @property ABBR_MONTHNAMES
		 * @static
		 * @type {Array}
		 */	
		ABBR_MONTHNAMES: &#x27;Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec&#x27;.split(&#x27; &#x27;),
		/**
		 * Names for the days of the week from Sunday to Saturday
		 * @property DAYNAMES
		 * @static
		 * @type {Array}
		 */			
		DAYNAMES: &#x27;Sunday Monday Tuesday Wednesday Thursday Friday Saturday&#x27;.split(&#x27; &#x27;),
		/**
		 * Lookup of day number by day abbreviation
		 * @property DAYNAMES_LOOKUP
		 * @static
		 * @type {Object}
		 */
		DAYNAMES_LOOKUP: {sun:0, mon:1, tue:2, wed:3, thu:4, fri:5, sat:6},
		/**
		 * Abbreviated names for the days of the week from Sunday to Saturday
		 * @property ABBR_DAYNAMES
		 * @static
		 * @type {Array}
		 */		
		ABBR_DAYNAMES: &#x27;Sun Mon Tue Wed Thu Fri Sat&#x27;.split(&#x27; &#x27;),
		/**
		 * The ordinal text (st, nd, rd, th) for digits 0 to 9
		 * @property ORDINALNAMES
		 * @static
		 * @type {Array}
		 */
		ORDINALNAMES: &#x27;th st nd rd th th th th th th&#x27;.split(&#x27; &#x27;),
		/**
		 * Pattern for full ISO-8601 date conversion - 2013-12-19T22:15:42.388-0600
		 * @property ISO
		 * @static
		 * @type {String}
		 */
		ISO: &#x27;%Y-%m-%dT%H:%M:%S.%N%G&#x27;,
		/**
		 * Pattern for SQL-type formatting - 2013-12-19 22:15:42
		 * @property SQL
		 * @static
		 * @type {String}
		 */
		SQL: &#x27;%Y-%m-%d %H:%M:%S&#x27;,
		/**
		 * The format code for producing RFC822 formatted dates - Thu, 19 Dec 2013 22:15:42 -0600
		 * @property RFC822
		 * @static
		 * @type {String}
		 */
		RFC822: &#x27;%a, %d %b %Y %H:%M:%S %#G&#x27;,
		/**
		 * The date of the script load
		 * @property SCRIPT_LOAD
		 * @static
		 * @type {Date}
		 */
		SCRIPT_LOAD: new Date(),
		/**
		 * Return the number of days in the given year and month. January = 1
		 * @method daysInMonth
		 * @static
		 * @param {Number} year
		 * @param {Number} month
		 * @return {Number}
		 * @example
		  
	Date.daysInMonth(2013,  
		 
		 */
		daysInMonth: function(year, month) {
			if (month == 2) {
				return new Date(year, 1, 29).getDate() == 29 ? 29 : 28;
			}
			return [undefined,31,undefined,31,30,31,30,31,31,30,31,30,31][month];
		},
		/**
		 * Given a month name or abbreviation, return the month number where January = 0
		 * @method getMonthByName
		 * @static
		 * @param {String} monthname
		 * @return {Number}
		 */
		getMonthByName: function(monthname) {
			return Date.MONTHNAMES_LOOKUP[ String(monthname).slice(0,3).toLowerCase() ];
		},
		/**
		 * Given a day name or abbreviation, return the day number where Sunday = 0
		 * @method getWeekdayByName
		 * @static
		 * @param {String} monthname
		 * @return {Number}
		 */		
		getWeekdayByName: function(dayname) {
			return Date.DAYNAMES_LOOKUP[ String(dayname).slice(0,3).toLowerCase() ];			
		},
		/**
		 * Set a form input to be automatically formatted to the given format. If not recognized, leave value alone
		 * @method autoFormat
		 * @static
		 * @param {HTMLElement|String} input  An HTML element or ID to which to attach the onblur event
		 * @param {String} [formatStr=&quot;Y-%m-%d %H:%M:%s&quot;]  The pattern with which to format the date
		 * @return {HTMLElement}
		 */
		autoFormat: function(input, formatStr) {
			input = (typeof input == &#x27;string&#x27; ? document.getElementById(input) : input);
			var correct = function() {
				var date = Date.create(input.value);
				if (date) {
					input.value = date.format(formatStr);
				}
			};
			if (typeof input.attachEvent == &#x27;function&#x27;) {
				input.attachEvent(&#x27;onblur&#x27;, correct);
			}
			else if (typeof input.addEventListener == &#x27;function&#x27;) {
				input.addEventListener(&#x27;blur&#x27;, correct, false);
			}
			else {
				input.onblur = correct;
			}
			return input;
		},
		/**
		 * Add a new set of format rules
		 * @method addFormat
		 * @static
		 * @param {String} name  The name of the method
		 * @param {Object} rules  A definition with keys matcher, defaultFormat, codes and shortcuts. See source code for examples.
		 * @return {this}
		 */
		addFormat: function(name, rules) {
			Date.prototype[name] = function(formatStr) {
				return this._applyFormat(formatStr, rules);
			};
			return this;
		},
		/**
		 * Add a new pattern for recognizing dates
		 * @method addPattern
		 * @static
		 * @param {Array} spec  An array containing 3 items: [name, regex, function or replace pattern]
		 * @param {String} [afterName]  The named pattern after which to add this pattern. When not given, place pattern at beginning
		 * @return {Object} 
		 * @example

	Date.addPattern([&#x27;month-year&#x27;, /^(\d{1,2})-(\d{4})$/, &#x27;$1/01/$2&#x27;]);
	Date.addPattern([&#x27;hoy&#x27;, /^hoy$/i, function(match) { return new Date(); }], &#x27;iso_8601&#x27;);

		 */
		addPattern: function(spec, afterName) {
			if (afterName) {
				var i = 0, pattern;
				while ((pattern = Date.create.patterns[i++])) {
					if (pattern[0] == afterName || pattern[1] == afterName) {
						Date.create.patterns.splice(i, 0, spec);
						return this;
					}
				}
			}
			// afterName not given or not found
			Date.create.patterns.unshift(spec);
			return this;
		},
		/**
		 * Remove a pattern by name
		 * @method removePattern
		 * @param {String} name  The name of the pattern to remove
		 * @return {Array|Boolean}  Returns the removed pattern or false if pattern not found
		 * @example

	Date.removePattern(&#x27;us&#x27;); // us-style m/d/Y dates no longer recognized
	var us = Date.removePattern(&#x27;us&#x27;); Date.addPattern(us, &#x27;world&#x27;); // prefer world-style d/m/Y dates over us-style dates
				
		 */
		removePattern: function(name) {
			var i = 0, pattern;
			while ((pattern = Date.create.patterns[i++])) {
				if (pattern[0] == name || pattern[1] == name) {
					// return 
					return Date.create.patterns.splice(i-1, 1)[0];
				}
			}
			return false;
		},
		/**
		 * Instantiate Date object representing the current date (allows unit testing and mocks)
		 * @method current
		 * @static
		 * @return {Date}
		 */
		current: function() {
			return new Date();
		}		
	};
	extend(Date, staticMethods);
	/**
	 * The version of this library
	 * @property create.version
	 * @static
	 * @type {String}
	 */
	Date.create.version = &#x27;%VERSION%&#x27;;
	
	// ES5 Shim
	if (!Date.now) {
		/**
		 * Return the current date in milliseconds past epoch relative to UTC time
		 * @method now
		 * @static
		 * @return {Date}
		 */
		Date.now = function() {
			return Date.current().setUTCOffset(0).getTime();
		};
	}
	
	//
	// format codes for strftime
	//
	// each code must be an array where the first member is the name of a Date.prototype function
	// and optionally a second member indicating the number to pass to Number#toPaddedString()
	//
	Date.addFormat(&#x27;strftime&#x27;, {
		//
		// 2-part regex matcher for format codes
		//
		// first match must be the character before the code (to account for escaping)
		// second match must be the format code character(s)
		//
		matcher: /()%(#?(%|[a-z]))/i,
		defaultFormat: &#x27;%Y-%m-%d %H:%M:%s&#x27;,
		codes: {
			// year
			Y: &#x27;FullYear&#x27;,
			y: &#x27;ShortYear.2&#x27;,
			// month
			m: &#x27;MonthNumber.2&#x27;,
		 &#x27;#m&#x27;: &#x27;MonthNumber&#x27;,
			B: &#x27;MonthName&#x27;,
			b: &#x27;AbbrMonthName&#x27;,
			// day
			d: &#x27;Date.2&#x27;,
		 &#x27;#d&#x27;: &#x27;Date&#x27;,
			e: &#x27;Date&#x27;,
			A: &#x27;DayName&#x27;,
			a: &#x27;AbbrDayName&#x27;,
			w: &#x27;Day&#x27;,
			o: &#x27;DayOrdinal&#x27;,
			// hours
			H: &#x27;Hours.2&#x27;,
		 &#x27;#H&#x27;: &#x27;Hours&#x27;,
			I: &#x27;Hours12.2&#x27;,
		 &#x27;#I&#x27;: &#x27;Hours12&#x27;,
			P: &#x27;AmPmLower&#x27;,
			p: &#x27;AmPm&#x27;,
			// minutes
			M: &#x27;Minutes.2&#x27;,
		 &#x27;#M&#x27;: &#x27;Minutes&#x27;,
			// seconds
			S: &#x27;Seconds.2&#x27;,
		 &#x27;#S&#x27;: &#x27;Seconds&#x27;,
			s: &#x27;Unix&#x27;,
			// milliseconds
			N: &#x27;Milliseconds.3&#x27;,
		 &#x27;#N&#x27;: &#x27;Milliseconds&#x27;,
			// timezone
			O: &#x27;TimezoneOffset&#x27;,
			Z: &#x27;TimezoneName&#x27;,
			G: &#x27;UTCOffset&#x27;,
		 &#x27;#G&#x27;: &#x27;getUTCOffsetNumber&#x27;
		},
		//
		// shortcuts that will be translated into their longer version
		//
		// be sure that format shortcuts do not refer to themselves: this will cause an infinite loop
		//
		shortcuts: {
			// date
			F: &#x27;%Y-%m-%d&#x27;,
			// time
			T: &#x27;%H:%M:%S&#x27;,
			X: &#x27;%H:%M:%S&#x27;,
			// local format date
			x: &#x27;%m/%d/%y&#x27;,
			D: &#x27;%m/%d/%y&#x27;,
			// local format extended
		 &#x27;#c&#x27;: &#x27;%a %b %e %H:%M:%S %Y&#x27;,
			// local format short
			v: &#x27;%e-%b-%Y&#x27;,
			R: &#x27;%H:%M&#x27;,
			r: &#x27;%I:%M:%S %p&#x27;,
			// tab and newline
			t: &#x27;\t&#x27;,
			n: &#x27;\n&#x27;,
			&#x27;%&#x27;: &#x27;%&#x27;
		}
	});
	Date.addFormat(&#x27;formatPhp&#x27;, {
		//
		// 2-part regex matcher for format codes
		//
		// first match must be the character before the code (to account for escaping)
		// second match must be the format code character(s)
		//
		matcher: /(\\)?([a-z])/i,
		defaultFormat: &#x27;Y-m-d H:i:s&#x27;,
		codes: {
			// year
			Y: &#x27;FullYear&#x27;,
			y: &#x27;ShortYear.2&#x27;,
			L: &#x27;isLeapYear&#x27;,
			// month
			m: &#x27;MonthNumber.2&#x27;,
			n: &#x27;MonthNumber&#x27;,
			F: &#x27;MonthName&#x27;,
			M: &#x27;AbbrMonthName&#x27;,
			t: &#x27;daysInMonth&#x27;,
			// day
			d: &#x27;Date.2&#x27;,
			j: &#x27;Date&#x27;,
			l: &#x27;DayName&#x27;,
			D: &#x27;AbbrDayName&#x27;,
			w: &#x27;Day&#x27;,
			S: &#x27;DayOrdinal&#x27;,
			// hours
			H: &#x27;Hours.2&#x27;,
			G: &#x27;Hours&#x27;,
			h: &#x27;Hours12.2&#x27;,
			g: &#x27;Hours12&#x27;,
			a: &#x27;AmPmLower&#x27;,
			A: &#x27;AmPm&#x27;,
			// minutes
			i: &#x27;Minutes.2&#x27;,
			// seconds
			s: &#x27;Seconds.2&#x27;,
			U: &#x27;Unix&#x27;,
			// timezone
			Z: &#x27;TimezoneOffset&#x27;,
			e: &#x27;TimezoneName&#x27;,
			P: &#x27;UTCOffset&#x27;,
			O: &#x27;UTCOffsetNumber&#x27;
		},
		//
		// shortcuts that will be translated into their longer version
		//
		// be sure that format shortcuts do not refer to themselves: this will cause an infinite loop
		//
		shortcuts: {
			// iso
			c: &#x27;Y-m-d\\TH:i:sP&#x27;,
			// rfc 2822
			r: &#x27;D, j M Y H:i:s O&#x27;
		}
	});
	var formatSql = {
		//
		// 2-part regex matcher for format codes
		//
		// first match must be the character before the code (to account for escaping)
		// second match must be the format code character(s)
		//
		matcher: /()(mi|am|pm|ss|yyyy|yy|m{1,4}|d{1,4}|w|hh?24|hh?12)/i,
		defaultFormat: &#x27;yyyy-mm-dd hh24:mi:ss&#x27;,
		codes: {
			// year
			yyyy: &#x27;FullYear&#x27;,
			yy: &#x27;ShortYear.2&#x27;,
			// month
			mm: &#x27;MonthNumber.2&#x27;,
			m: &#x27;MonthNumber&#x27;,
			mmm: &#x27;AbbrMonthName&#x27;,
			mmmm: &#x27;MonthName&#x27;,
			// day
			dd: &#x27;Date.2&#x27;,
			d: &#x27;Date&#x27;,
			ddd: &#x27;AbbrDayName&#x27;,
			dddd: &#x27;DayName&#x27;,
			w: &#x27;Day&#x27;,
			// hours
			hh24: &#x27;Hours.2&#x27;,
			h24: &#x27;Hours&#x27;,
			hh: &#x27;Hours12.2&#x27;,
			hh12: &#x27;Hours12.2&#x27;,
			h12: &#x27;Hours12&#x27;,
			am: &#x27;AmPm&#x27;,
			pm: &#x27;AmPm&#x27;,
			// minutes
			mi: &#x27;Minutes.2&#x27;,
			// seconds
			ss: &#x27;Seconds.2&#x27;
		},
		//
		// shortcuts that will be translated into their longer version
		//
		// be sure that format shortcuts do not refer to themselves: this will cause an infinite loop
		//
		shortcuts: {}
	};

	// add uppercase versions of each sql code
	var keys = &#x27;yyyy yy mm m mmm mmmm dd d ddd dddd w hh24 h24 hh12 h12 am pm mi ss&#x27;.split(&#x27; &#x27;), i = 0, key;
	while ((key = keys[i++])) {
		formatSql.codes[key.toUpperCase()] = formatSql.codes[key];
	}
	Date.addFormat(&#x27;formatSql&#x27;, formatSql);

	/**
	 * A list of conversion patterns used in regexes
	 * @property create.regexes
	 * @static
	 */
	Date.create.regexes = {
		YEAR: &quot;[1-9]\\d{3}&quot;,
		MONTH: &quot;1[0-2]|0?[1-9]&quot;,
		MONTH2: &quot;1[0-2]|0[1-9]&quot;,
		MONTHNAME: &quot;jan|january|feb|february|mar|march|apr|april|may|jun|june|jul|july|aug|august|sep|september|oct|october|nov|november|dec|december&quot;,
		DAYNAME: &quot;mon|monday|tue|tuesday|wed|wednesday|thu|thursday|fri|friday|sat|saturday|sun|sunday&quot;,
		DAY: &quot;3[01]|[12]\\d|0?[1-9]&quot;,
		DAY2: &quot;3[01]|[12]\\d|0[1-9]&quot;,
		TIMEZONE: &quot;[+-][01]\\d\\:?[0-5]\\d&quot;,
		H24: &quot;[01]\\d|2[0-3]&quot;,
		MIN: &quot;[0-5]\\d&quot;,
		SEC: &quot;[0-5]\\d&quot;,
		MS: &quot;\\d{3,}&quot;,
		H12: &quot;0?[1-9]|1[012]&quot;,
		AMPM: &quot;am|pm&quot;,
		UNIT: &quot;year|month|week|day|hour|minute|second|millisecond&quot;
	};
	
	/**
	 * Make a regex given a string containing patterns in Date.create.regexes
	 * @param {type} code
	 * @return {RegExp}
	 * @example
	 
	 Date.create.makePattern(&quot;^(_YEAR_)-(_MONTH_)-(_DAY_)$&quot;); // RegExp
	  
	 */
	Date.create.makePattern = function(code) {
		code = code.replace(/_([A-Z][A-Z0-9]+)_/g, function($0, $1) {
			return Date.create.regexes[$1];
		});
		return new RegExp(code, &#x27;i&#x27;);
	};
	
	/**
	 * An array of all the patterns used to parse dates
	 * @property create.patterns
	 * @static
	 */
	Date.create.patterns = [
		// 2010-03-15
		[
			&#x27;iso_8601&#x27;,
			Date.create.makePattern(&quot;^(_YEAR_)-(_MONTH_)-(_DAY_)$&quot;), 
			&#x27;$2/$3/$1&#x27;
		],

		// 3-15-2010
		[
			&#x27;us&#x27;, 
			Date.create.makePattern(&quot;^(_MONTH_)([\\/-])(_DAY_)\\2(_YEAR_)$&quot;), 
			&#x27;$1/$3/$4&#x27;
		],

		// 15.03.2010
		[
			&#x27;world&#x27;, 
			Date.create.makePattern(&quot;^(_DAY_)([\\/\\.])(_MONTH_)\\2(_YEAR_)$&quot;), 
			&#x27;$3/$1/$4&#x27;
		],

		// 15-Mar-2010, 8 Dec 2011, &quot;Thu, 8 Dec 2011&quot;
		[
			&#x27;chicago&#x27;,
			Date.create.makePattern(&quot;^(?:(?:_DAYNAME_),? )?(_DAY_)([ -])(_MONTHNAME_)\\2(_YEAR_)$&quot;),
			&#x27;$3 $1, $4&#x27;
		],

		// &quot;March 4, 2012&quot;, &quot;Mar 4 2012&quot;, &quot;Sun Mar 4 2012&quot;
		[
			&#x27;conversational&#x27;, 
			Date.create.makePattern(&quot;^(?:(?:_DAYNAME_),? )?(_MONTHNAME_) (_DAY_),? (_YEAR_)$&quot;), 
			&#x27;$1 $2, $3&#x27;
		],

		// Tue Jun 22 17:47:27 +0000 2010
		[
			&#x27;month_day_time_year&#x27;, 
			Date.create.makePattern(&quot;^(?:_DAYNAME_) (_MONTHNAME_) (_DAY_) ((?:_H24_)\\:(?:_MIN_)(?:\\:_SEC_)?) (_TIMEZONE_) (_YEAR_)$&quot;),
			function(m) {
				var month = zeroPad( Date.getMonthByName(m[1]), 2 );
				var day = zeroPad( m[2], 2 );
				var date = Date.create(m[5] + &#x27;-&#x27; + month + &#x27;-&#x27; + day + &#x27;T&#x27; + m[3] + m[4]);
				if (isNaN(date)) {
					return false;
				}
				return date;
			}
		],
		
		// @123456789
		[
			&#x27;unix&#x27;, 
			/^@(-?\d+)$/, 
			function(match) {
				return Date.create(parseInt(match[1], 10) * 1000);
			}
		],
	
		// 24-hour time (This will help catch Date objects that are casted to a string)
		[
			&#x27;24_hour&#x27;,
			Date.create.makePattern(&quot;^(?:(.+?)(?: |T))?(_H24_)\\:(_MIN_)(?:\\:(_SEC_)(?:\\.(_MS_))?)? ?(?:GMT)?(_TIMEZONE_)?(?: \\([A-Z]+\\))?$&quot;), 
			function(match) {
				var d;
				if (match[1]) {
					d = Date.create(match[1]);
					if (isNaN(d)) {
						return false;
					}
				} else {
					d = Date.current();
					d.setMilliseconds(0);
				}
				d.setHours(parseFloat(match[2]), parseFloat(match[3]), parseFloat(match[4] || 0));
				if (match[5]) {
					d.setMilliseconds(+String(match[5]).slice(0,3));
				}
				if (match[6]) {
					d.setUTCOffsetString(match[6]);
				}
				return d;
			}
		],

		// 12-hour time
		[
			&#x27;12_hour&#x27;, 
			Date.create.makePattern(&quot;^(?:(.+) )?(_H12_)(?:\\:(_MIN_)(?:\\:(_SEC_))?)? ?(_AMPM_)$&quot;),
			function(match) {
				var d;
				if (match[1]) {
					d = Date.create(match[1]);
					if (isNaN(d)) {
						return false;
					}
				} else {
					d = Date.current();
					d.setMilliseconds(0);
				}
				var hour = parseFloat(match[2]);
				hour = match[5].toLowerCase() == &#x27;am&#x27; ? (hour == 12 ? 0 : hour) : (hour == 12 ? 12 : hour + 12);
				d.setHours(hour, parseFloat(match[3] || 0), parseFloat(match[4] || 0));
				return d;
			}
		],

		// 2 weeks after today, 3 months after 3-5-2008
		[
			&#x27;weeks_months_before_after&#x27;,
			Date.create.makePattern(&quot;^(\\d+) (_UNIT_)s? (before|from|after) (.+)$&quot;),
			function(match) {
				var fromDate = Date.create(match[4]);
				if (fromDate instanceof Date) {
					return fromDate.add((match[3].toLowerCase() == &#x27;before&#x27; ? -1 : 1) * match[1], match[2]);
				}
				return false;
			}
		],

		// 5 months ago
		[
			&#x27;time_ago&#x27;, 
			Date.create.makePattern(&quot;^(\\d+) (_UNIT_)s? ago$&quot;), 
			function(match) {
				return Date.current().add(-1 * match[1], match[2]);
			}
		],

		// in 2 hours/weeks/etc.
		[
			&#x27;in_time&#x27;, 
			Date.create.makePattern(&quot;^in (\\d) (_UNIT_)s?$&quot;), 
			function(match) {
				return Date.current().add(match[1], match[2]);
			}
		],
	
		// &quot;+2 hours&quot;, &quot;-3 years&quot;
		[
			&#x27;plus_minus&#x27;, 
			Date.create.makePattern(&quot;^([+-]) ?(\\d+) (_UNIT_)s?$&quot;), function(match) {
				var mult = match[1] == &#x27;-&#x27; ? -1 : 1;
				return Date.current().add(mult * match[2], match[3]);
			}
		],
	
		// &quot;/Date(1296824894000)/&quot;, &quot;/Date(1296824894000-0700)/&quot;
		[
			&#x27;asp_json&#x27;,
			/^\/Date\((\d+)([+\-]\d{4})?\)\/$/i,
			function(match) {
				var d = new Date();
				d.setTime(match[1]);
				if (match[2]) {
					d.setUTCOffsetString(match[2]);
				}
				return d;
			}
		],	

		// today, tomorrow, yesterday
		[
			&#x27;today_tomorrow&#x27;,
			/^(today|now|tomorrow|yesterday)/i,
			function(match) {
				var now = Date.current();
				switch (match[1].toLowerCase()) {
					case &#x27;today&#x27;:
					case &#x27;now&#x27;:
						return now;
					case &#x27;tomorrow&#x27;:
						return now.add(1, &#x27;day&#x27;);
					case &#x27;yesterday&#x27;:
						return now.add(-1, &#x27;day&#x27;);
				}
			}
		],

		// this/next/last january, next thurs
		[
			&#x27;this_next_last&#x27;, 
			Date.create.makePattern(&quot;^(this|next|last) (?:(_UNIT_)s?|(_MONTHNAME_)|(_DAYNAME_))$&quot;), 
			function(match) {
				// $1 = this/next/last
				var multiplier = match[1].toLowerCase() == &#x27;last&#x27; ? -1 : 1;
				var now = Date.current();
				var i;
				var diff;
				var month;
				var weekday;
				// $2 = interval name
				if (match[2]) {
					return now.add(multiplier, match[2]);
				}
				// $3 = month name
				else if (match[3]) {
					month = Date.getMonthByName(match[3]) - 1;
					diff = 12 - (now.getMonth() - month);
					diff = diff &gt; 12 ? diff - 12 : diff;
					return now.add(multiplier * diff, &#x27;month&#x27;);
				}
				// $4 = weekday name
				else if (match[4]) {
					weekday = Date.getWeekdayByName(match[4]);
					diff = now.getDay() - weekday + 7;
					return now.add(multiplier * (diff === 0 ? 7 : diff), &#x27;day&#x27;);
				}
				return false;
			}
		],

		// January 4th, July the 4th
		[
			&#x27;conversational_sans_year&#x27;, 
			Date.create.makePattern(&quot;^(_MONTHNAME_) (?:the )?(\\d+)(?:st|nd|rd|th)?$&quot;), 
			function(match) {
				var d = Date.current();
				if (match[1]) {
					d.setMonth( Date.getMonthByName(match[1]) - 1 );
				}
				d.setDate(match[2]);
				return d;
			}
		]
	];

})();

// add $D shortcut to window or send Date.create to module.exports using UMD pattern
// see https://github.com/umdjs/umd/blob/master/returnExports.js
(function(root, factory) {
	if (typeof define == &#x27;function&#x27; &amp;&amp; define.amd) {
		// AMD. Register as an anonymous module.
		define(factory);
	}
	else if (typeof exports == &#x27;object&#x27;) {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like enviroments that support module.exports,
		// like Node.
		module.exports = factory();
	}
	else if (root) {
		// Browser globals (root is window)
		root.$D = factory();
	}
}(this, function() {
	return Date.create;
}));


// Docs for YUIDoc to pick up on native Date methods
/**
 * @class Date
 */
/**
 * @constructor
 * @param {Number} milliseconds
 */
/**
 * Get the day of the month (1-31)
 * @method getDate
 * @return {Number}
 */
/**
 * Get the day of the week (0=Sunday, 6=Saturday)
 * @method getDay
 * @return {Number}
 */
/**
 * Get the month number (0=January, 11=December)
 * @method getMonth
 * @return {Number}
 */
/**
 * Get the four-digit year
 * @method getFullYear
 * @return {Number}
 */
/**
 * Get the number of years since 1900 (such that a 2013 date returns 113)
 * @method getYear
 * @return {Number}
 */
/**
 * Get the hour (0-23)
 * @method getHours
 * @return {Number}
 */
/**
 * Get minutes (0-59)
 * @method getMinutes
 * @return {Number}
 */
/**
 * Get seconds (0-59)
 * @method getSeconds
 * @return {Number}
 */
/**
 * Get milliseconds (0-999)
 * @method getMilliseconds
 * @return {Number}
 */
/**
 * Get the number of milliseconds since 1970-01-01 00:00:00
 * @method getTime
 * @return {Number}
 */
/**
 * Get the number of minutes between the local timezone and UTC time.
 * Note that the offset is the same for all Date objects
 * @method getTimezoneOffset
 * @return {Number}
 */
/**
 * Convert to UTC then get the day of the month (1-31)
 * @method getUTCDate
 * @return {Number}
 */
/**
 * Convert to UTC then get the day of the week (0=Sunday, 6=Saturday)
 * @method getUTCDay
 * @return {Number}
 */
/**
 * Convert to UTC then get the month number (0=January, 11=December)
 * @method getUTCMonth
 * @return {Number}
 */
/**
 * Convert to UTC then get the four-digit year
 * @method getUTCFullYear
 * @return {Number}
 */
/**
 * Convert to UTC then get the hour (0-23)
 * @method getUTCHours
 * @return {Number}
 */
/**
 * Convert to UTC then get minutes (0-59)
 * @method getUTCMinutes
 * @return {Number}
 */
/**
 * Convert to UTC then get seconds (0-59)
 * @method getUTCSeconds
 * @return {Number}
 */
/**
 * Convert to UTC then get milliseconds (0-999)
 * @method getUTCMilliseconds
 * @return {Number}
 */
/**
 * Set the day of the month (1-31)
 * @method setDate
 * @param {Number} day
 * @return {Number}  The number of milliseconds since 1970-01-01 00:00:00 
 */
/**
 * Set the month number (0=January, 11=December)
 * @method setMonth
 * @param {Number} month
 * @return {Number}  The number of milliseconds since 1970-01-01 00:00:00 
 */
/**
 * Set the four-digit year
 * @method setFullYear
 * @param {Number} year
 * @return {Number}  The number of milliseconds since 1970-01-01 00:00:00 
 */
/**
 * Set the number of years since 1900 (such that a 113 produces a date in 2013)
 * @method setYear
 * @param {Number} yearsSince1900
 * @return {Number}  The number of milliseconds since 1970-01-01 00:00:00 
 */
/**
 * Set the hour (0-23) and optionally minutes, seconds, and milliseconds
 * @method setHours
 * @param {Number} hours
 * @param {Number} [minutes]
 * @param {Number} [seconds]
 * @param {Number} [milliseconds]
 * @return {Number}  The number of milliseconds since 1970-01-01 00:00:00 
 */
/**
 * Set minutes (0-59) and optionally seconds and milliseconds
 * @method setMinutes
 * @param {Number} minutes
 * @param {Number} [seconds]
 * @param {Number} [milliseconds]
 * @return {Number}  The number of milliseconds since 1970-01-01 00:00:00 
 */
/**
 * Set seconds (0-59) and optionally milliseconds
 * @method setSeconds
 * @param {Number} seconds
 * @param {Number} [milliseconds]
 * @return {Number}  The number of milliseconds since 1970-01-01 00:00:00 
 */
/**
 * Set milliseconds (0-999)
 * @method setMilliseconds
 * @param {Number} milliseconds
 * @return {Number}  The number of milliseconds since 1970-01-01 00:00:00 
 */
/**
 * Set the number of milliseconds past 1970-01-01 00:00:00
 * @method setTime
 * @param {Number} milliseconds
 * @return {Number}  The number of milliseconds since 1970-01-01 00:00:00
 */
/**
 * Convert the date to a string in the format &quot;2013-12-20T04:34:43.284Z&quot;
 * @method toISOString
 * @return {String}
 */
/**
 * Get the number of milliseconds since 1970-01-01 00:00:00
 * @method valueOf
 * @return {Number}
 */
/**
 * Get a string representation of the date in 
 * @method toString
 * @return {Number}
 */
/**
 * Parse a string representation into a number of milliseconds since 1970-01-01 00:00:00.
 * Parsing capability varies by year
 * @method parse
 * @param {String} date
 * @return {Number}
 */
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
